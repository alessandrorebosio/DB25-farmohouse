\documentclass[a4paper,12pt]{report}

% Codifica, lingua, font
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[italian]{babel}
\usepackage{lmodern}

% Impaginazione
\usepackage{geometry}

% Grafica, colori, tabelle, float
\usepackage{graphicx}
\usepackage{float}
\usepackage[table]{xcolor}
\usepackage{tabularx}

% Matematica
\usepackage{amsmath}

% Verbatim e listing
\usepackage{fancyvrb}
\usepackage{alltt}
\usepackage{listings}

% Liste
% \usepackage{enumitem}

% Link e riferimenti intelligenti (hyperref prima di cleveref)
\usepackage{hyperref}
% \usepackage[italian]{cleveref}

\geometry{margin=1in}

% colori
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codeBlue}{HTML}{6495ED}
\definecolor{codegreen}{HTML}{12911F}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% stile listings
\lstdefinestyle{sqlstyle}{
  language=SQL,
  backgroundcolor=\color{backcolour},
  commentstyle=\color{codegreen}\itshape,
  keywordstyle=\color{codeBlue}\bfseries,
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codeBlue},
  basicstyle=\footnotesize\ttfamily,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  keepspaces=true,
  numbers=left,
  numbersep=10pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false
}

% ambiente dedicato
\lstnewenvironment{sqlcode}[1][]{
  \lstset{style=sqlstyle,#1}
}{}

\hypersetup{
  colorlinks=false,
  pdfborder={1 1 1},
  linkbordercolor={1 0 0},
  urlbordercolor={1 0 0},
  citebordercolor={1 0 0},
  pdftitle={Elaborato Basi di Dati},
  pdfauthor={Maisam Noumi, Alessandro Rebosio, Filippo Ricciotti}
}

\title{
  \vspace*{2cm}
  \LARGE Relazione per il corso di \\[0.5cm]
  \textit{Basi di Dati} \\[2cm]
  \Huge\textbf{Agriturismo} \\[2cm]
}

\author{
  \Large
  Alessandro Rebosio \\
  Filippo Ricciotti
}

\date{
  \vspace{1cm}
  \today \\[0.5cm]
  Anno Accademico 2024-2025
}

\begin{document}

\maketitle

\tableofcontents

\chapter{Analisi dei requisiti}
\section{Intervista}

L'agriturismo intende dotarsi di una piattaforma digitale che
razionalizzi le attività quotidiane
e migliori l'esperienza dei clienti, integrando in un unico ambiente
la gestione del personale,
la vendita di prodotti e la promozione di eventi. Il titolare
desidera uno strumento accessibile
via web, utilizzabile da utenti registrati e dal personale
autorizzato, in grado di offrire una
visione chiara e centralizzata delle informazioni operative,
riducendo errori e tempi di
coordinamento.

Il cuore dell'applicativo è costituito da un catalogo di prodotti e
da un calendario di
eventi, visibili ai visitatori e consultabili dagli utenti
registrati. I prodotti, identificati
da un codice univoco, sono descritti da un nome e da un prezzo, con
la garanzia che i valori
economici rimangano sempre positivi. Gli eventi, invece, sono
presentati con titolo,
descrizione, data di svolgimento e un numero di posti disponibili; la
loro pubblicazione è
effettuata da dipendenti autorizzati, così da mantenere controllo e
coerenza dell'offerta.

Gli utenti potranno creare un account fornendo un nome utente, un
indirizzo email e una
password; ogni profilo sarà associato a una persona identificata
tramite codice fiscale,
così da assicurare un'anagrafica pulita e non ridondante. Una volta
autenticati, gli utenti
potranno consultare il catalogo, comporre ordini di acquisto di
prodotti e completarne la
registrazione: ogni ordine sarà tracciato con data e ora, e conterrà
le righe di dettaglio con
quantità e prezzo unitario, in modo da consentire il calcolo del
totale e la successiva
rendicontazione. Gli acquisti rimarranno associati in modo permanente
all'account dell'utente,
così da poterli rivedere e analizzare nel tempo.

Per la dimensione esperienziale dell'agriturismo, la piattaforma
offrirà una sezione dedicata
agli eventi: gli utenti interessati potranno iscriversi indicando il
numero di partecipanti; il
sistema dovrà garantire che le prenotazioni non superino i posti
disponibili e registrerà
automaticamente data e ora di ciascuna iscrizione. In questo modo, il
titolare potrà monitorare
in tempo reale l'andamento delle adesioni e prevedere l'affluenza,
ottimizzando l'organizzazione
delle serate e delle attività tematiche.

La gestione del personale rappresenta un altro pilastro del sistema.
Ciascun dipendente sarà un
utente abilitato a funzioni specifiche e caratterizzato da un ruolo
(ad esempio sala, cucina,
reception), con la possibilità di tracciarne lo storico delle
variazioni nel tempo. La
pianificazione dei turni avverrà attraverso la definizione di modelli
di turno (per giorno della
settimana, con orari di inizio e fine) e la loro assegnazione a
calendario per una data
specifica. Ogni assegnazione prevede uno stato — programmato,
completato o assente — così da
fotografare l'effettiva presenza; inoltre, il sistema eviterà
conflitti, impedendo che uno
stesso dipendente risulti assegnato a più turni nella medesima giornata.

Dal punto di vista direzionale, il titolare richiede una reportistica
essenziale ma
affidabile: l'andamento delle vendite per periodo, la partecipazione
agli eventi e un quadro
della presenza/assenza del personale sui turni. La piattaforma dovrà
salvaguardare la sicurezza
dei dati, conservando le password in forma sicura e applicando
vincoli di integrità su prezzi e
quantità; le operazioni frequenti — come consultare il catalogo,
registrare un ordine o
iscriversi a un evento — dovranno risultare rapide e semplici,
privilegiando chiarezza e
immediatezza d'uso.

\section{Estrazione dei concetti principali}

L'agriturismo intende realizzare una piattaforma digitale che unisca
in un unico ecosistema la
vendita di prodotti, la promozione e gestione degli eventi e
l'organizzazione del personale. Il
sistema sarà accessibile via web agli utenti registrati e al
personale autorizzato, con
l'obiettivo di offrire una vista centralizzata e coerente delle
attività quotidiane, riducendo
errori operativi e tempi di coordinamento. Il cuore dell'applicazione
è rappresentato da un
\textbf{catalogo di \underline{prodotti}} e da un calendario
\underline{eventi}: i
\underline{prodotti}, identificati in modo univoco (\textbf{codice}),
e descritti da
\textbf{nome} e \textbf{prezzo}, saranno acquistabili dagli
\underline{utenti} autenticati; gli
\underline{eventi}, caratterizzati da \textbf{titolo},
\textbf{descrizione}, \textbf{data} e
\textbf{posti disponibili}, saranno visibili e prenotabili secondo
regole di capienza stabilite
dall'azienda.

Gli \underline{utenti} potranno creare un account fornendo
\textbf{nome utente}, \textbf{email}
e \textbf{password}; ogni account sarà associato a una
\underline{persona} identificata da
\textbf{codice fiscale}, in modo da mantenere un'anagrafica solida e
priva di duplicati. Una
volta autenticati, gli \underline{utenti} potranno consultare il
catalogo e comporre
\underline{ordini}, che verranno registrati con \textbf{data} e
\textbf{ora} e articolati in
\underline{righe d'ordine} di dettaglio con \textbf{quantità} e
\textbf{prezzo unitario},
garantendo la correttezza dei totali e la tracciabilità nel tempo.
Gli \underline{acquisti}
resteranno permanentemente associati al profilo
dell'\underline{utente}, consentendo
storicizzazione e successive analisi gestionali.

La dimensione esperienziale sarà supportata da un modulo
\underline{eventi}: la creazione degli
\underline{eventi} è affidata a \underline{dipendenti} autorizzati e
prevede l'indicazione dei
\textbf{posti disponibili}. Gli \underline{utenti} potranno
iscriversi (\underline{iscrizione
evento}) specificando il \textbf{numero di partecipanti}, mentre il
sistema dovrà prevenire
il superamento della capienza e registrare automaticamente
\textbf{data} e \textbf{ora} di ogni
iscrizione. In parallelo, la gestione interna del
\underline{personale} è fondata su
\underline{ruoli} e \underline{turni}: ogni \underline{dipendente}
possiede un \textbf{ruolo}
corrente, con storico delle variazioni per fini di audit, e partecipa
a una pianificazione che
combina \underline{modelli di turno} (\textbf{giorno della
  settimana}, \textbf{nome},
\textbf{orari}) con \underline{assegnazioni di turno} a calendario
per \textbf{date} specifiche.
Ogni assegnazione registra lo \textbf{stato} effettivo (\textbf{programmato},
\textbf{completato}, \textbf{assente}) e impedisce conflitti, evitando che un
\underline{dipendente} risulti pianificato su più turni nello stesso giorno.

A livello trasversale, la piattaforma tutela integrità e sicurezza
dei dati: \textbf{prezzi} e
\textbf{quantità} devono essere sempre positivi, le relazioni fra
\underline{utenti},
\underline{dipendenti}, \underline{ordini} ed \underline{eventi}
rispettano vincoli
referenziali, e le informazioni sensibili come le \textbf{password}
sono gestite in modo sicuro.

Il \underline{titolare} dispone di una visione complessiva tramite
report essenziali su
\underline{vendite}, \underline{adesioni agli eventi} e
\underline{presenza del personale},
mentre l'interfaccia privilegia semplicità e rapidità nelle
operazioni più frequenti.

\chapter{Progettazione concettuale}
In questo capitolo presenteremo lo schema ER, partendo da una
versione iniziale e migliorandola
passo dopo passo ad arrivare a quella definitiva, attraverso dei raffinamenti.

\section{Schema iniziale}
Dopo aver eseguito l'analisi del dominio iniziale, abbiamo creato uno
schema di base con
le entità e le relazioni principali, che sarà poi perfezionato nei
passaggi successivi.
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth, trim=200pt 170pt 50pt 0pt,
  clip]{./schemas/base.pdf}
  \caption{Schema ER iniziale}
  \label{fig:schema-iniziale}
\end{figure}

\section{Raffinamenti proposti}
\subsection{Utente e Dipendente}
Nel modello concettuale iniziale la \textbf{Persona} raggruppava
tutte le possibili interazioni
con il sistema: iscrizione, creazione di eventi, prenotazioni, ordini
e recensioni. Questo
approccio, sebbene corretto dal punto di vista logico, risultava poco
chiaro perché attribuiva
a un'unica entità responsabilità molto eterogenee.

\vspace{\baselineskip}
Per migliorare la rappresentazione è stato introdotto un raffinamento mediante
generalizzazione/specializzazione: la superclasse \textbf{Persona} è
stata mantenuta per
raccogliere gli attributi comuni (CF, nome, cognome), mentre le
funzionalità specifiche sono
state assegnate ai sottotipi \textbf{Cliente} e \textbf{Dipendente}.

\vspace{\baselineskip}
In questo modo i clienti gestiscono attività come acquisti,
recensioni, ordini e iscrizioni agli
eventi, mentre i dipendenti si occupano della creazione degli eventi
e della gestione dei
servizi. Tale raffinamento migliora la chiarezza semantica del
modello, riduce le ambiguità e
riflette meglio la separazione dei ruoli reali all'interno del
dominio applicativo.

\vspace{\baselineskip}
Il raffinamento mette in evidenza anche le dipendenze temporali (come
  la gestione dei turni \textbf{Shift} o la cronologia del personale
\textbf{Employee History}) e garantisce che ogni operazione rispetti
vincoli di consistenza e cardinalità, rendendo il modello complessivo
coerente, sicuro e facilmente estendibile.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth, trim=0 200pt 275pt 0,
  clip]{./schemas/refinements/user.pdf}
  \caption{Raffinamento utente e dipendente}
  \label{fig:raffinamento-utente}
\end{figure}

\newpage
\subsection{Prenotazione Servizi}
Nel modello iniziale i diversi tipi di servizi potevano essere
rappresentati come entità
distinte, con il rischio però di ridondanza e frammentazione dei dati.

\vspace{\baselineskip}
Con il raffinamento si è introdotta una \textbf{generalizzazione}: è
stata creata la superclasse
\textbf{Servizio}, che raccoglie gli attributi comuni (id, price,
type), mentre ciascuna
tipologia specifica di servizio (Camera e Ristorante) è modellata
come sottoclasse.

\vspace{\baselineskip}
Inoltre, è stato introdotto il legame con l'entità
\textbf{Prenotazione}, che consente di
registrare le informazioni su data di inizio e fine e di associare
ogni prenotazione a uno o
più servizi specifici tramite la relazione con \textbf{Dettagli
Prenotazione}. Questo
raffinamento permette di gestire correttamente scenari in cui un
utente prenota più servizi
differenti nello stesso arco temporale.
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth, trim=0 200pt 300pt 0,
  clip]{./schemas/refinements/service.pdf}
  \caption{Raffinamento prenotazione e servizi}
  \label{fig:raffinamento-servizi-prenotazione}
\end{figure}

\newpage
\subsection{Prodotti e ordini}
Nel modello concettuale iniziale, la gestione degli ordini e dei
prodotti risultava poco
dettagliata: un ordine era semplicemente collegato a uno o più
prodotti, senza possibilità di
specificare informazioni aggiuntive come quantità o prezzo unitario.

\vspace{\baselineskip}
Con il raffinamento, è stata introdotta l'entità \textbf{Dettaglio
Ordine}, che funge da
associazione tra \textbf{Ordine} e \textbf{Prodotto}. Ogni dettaglio
ordine consente di
memorizzare, per ciascun prodotto incluso in un ordine, la quantità
acquistata e il prezzo
applicato. Questo permette di rappresentare in modo accurato scenari
reali come ordini
multiprodotto, applicazione di sconti o variazioni di prezzo nel tempo.

\vspace{\baselineskip}
Inoltre, viene mantenuta la generalizzazione tra \textbf{Persona} e
\textbf{Utente}, già
introdotta nei raffinamenti precedenti, per distinguere i dati
anagrafici comuni da quelli
specifici per l'accesso al sistema e la gestione degli ordini. Questo
approccio migliora la
flessibilità e la chiarezza del modello, consentendo una gestione più efficace
delle informazioni relative agli acquisti.
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth, trim=0 300pt 325pt 0,
  clip]{./schemas/refinements/product.pdf}
  \caption{Raffinamento prodotti e ordini}
  \label{fig:raffinamento-prodotto-ordini}
\end{figure}

\newpage
\section{Schema concettuale finale}
Qui di seguito, è presente lo schema concettuale finale con tutti i
raffinamenti.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth, trim=0 0 0
  0]{./schemas/refinements/final.pdf}
  \caption{Schema ER, schema concettuale finale}
  \label{fig:schema-finale}
\end{figure}

\newpage
\chapter{Progettazione Logica}

\section{Stima del volume di dati}
Sulla base dei requisiti e dell'analisi di dominio, abbiamo stimato l'ordine
di grandezza dei dati iniziali e la crescita annua attesa per ciascuna
entità principale. La Tabella~\ref{tab:volume-dati} riassume i volumi e la
crescita previsti; i valori sono indicativi e utili per dimensionare indici,
partizionamento e politiche di archiviazione.

\begin{table}[H]
  \centering
  \begin{tabularx}{\textwidth}{|X|c|c|}
    \hline
    \rowcolor{gray!15}
    \textbf{Tabella} & \textbf{Volume stimato} & \textbf{E/A} \\
    \hline
    \texttt{ORDER} & 15\,000 & E \\
    \texttt{RESERVATION} & 8\,000 & E \\
    \texttt{PERSON} & 6\,000 & E \\
    \texttt{USER} & 5\,000 & E \\
    \texttt{REVIEW} & 3\,000 & E \\
    \texttt{PRODUCT} & 500 & E \\
    \texttt{EVENT} & 150 & E \\
    \texttt{SERVICE} & 100 & E \\
    \texttt{EMPLOYEE} & 50 & E \\
    \texttt{ROOM} & 30 & E \\
    \texttt{SHIFT} & 20 & E \\
    \texttt{RESTAURANT} & 5 & E \\
    \texttt{ORDER\_DETAIL} & 45\,000  & A \\
    \texttt{EMPLOYEE\_SHIFT} & 18\,000 & A \\
    \texttt{RESERVATION\_DETAIL} & 12\,000 & A \\
    \texttt{SUBSCRIPTION} & 2\,500 & A \\
    \texttt{EMPLOYEE\_HISTORY} & 80 & A \\
    \hline
  \end{tabularx}

  \caption{Stima volumi e classificazione Entità (E) o Associazione (A)}
  \label{tab:volume-dati}
\end{table}

\section{Descrizione operazioni}
\section{Analisi delle operazioni}
\section{Analisi delle ridondanze}
\section{Riepilogo Operazioni}

\section{Raffinamento dello schema}

In questa sezione descriviamo i passaggi di raffinamento dello schema ER per renderlo adatto all'implementazione nel modello relazionale. Seguiamo un approccio sistematico che include la rimozione degli attributi multivalore, la gestione delle gerarchie, la reificazione delle associazioni molti-a-molti e la scelta degli identificatori principali.

\subsection{Rimozione attributi multivalore}

Nel nostro schema ER non sono presenti attributi multivalore significativi. Tutti gli attributi identificati sono atomici e non richiedono decomposizione. Gli indirizzi, se presenti, sono già stati scomposti in via, civico, comune e CAP nelle entità rilevanti.

\subsection{Rimozione gerarchie}

Lo schema ER presenta alcune gerarchie (generalizzazioni) che devono essere tradotte nel modello relazionale. Analizziamo ciascuna caso specifico.

\subsubsection{Gerarchia di Servizio}

L'entità SERVICE presenta una gerarchia con le sottoclassi ROOM e RESTAURANT. Questa gerarchia è di tipo \textbf{totale ed esclusiva}. 

Abbiamo deciso di \textbf{non collassare} questa gerarchia verso l'alto per mantenere l'espandibilità del catalogo dei servizi. In futuro, potrebbero essere aggiunti nuovi tipi di servizi (ad esempio, piscina, spa, attività ricreative) senza necessità di modificare la struttura esistente. 

La scelta implementativa prevede:
- Mantenimento dell'entità SERVICE con attributi comuni (id, price, type)
- Creazione di tabelle separate per ROOM e RESTAURANT con chiave esterna verso SERVICE
- Il campo \textit{type} in SERVICE funge da selettore per identificare il tipo specifico

Questa soluzione offre massima flessibilità per l'aggiunta di nuovi servizi mantenendo l'integrità referenziale.

\subsubsection{Gerarchia di Persona}

La gerarchia PERSONA → USER → EMPLOYEE è stata gestita con un approccio misto:

- \textbf{PERSONA e USER}: Collasso verso l'alto, poiché ogni USER deve essere una PERSONA
- \textbf{USER e EMPLOYEE}: Sostituzione con associazione, dato che non ogni USER è un EMPLOYEE

Questa scelta permette di mantenere l'anagrafica centralizzata mentre distingue chiaramente i ruoli degli utenti nel sistema.

\subsubsection{Gerarchia di Prenotazione}

L'associazione tra RESERVATION e SERVICE è stata reificata nell'entità RESERVATION\_DETAIL, che permette di gestire le prenotazioni multiple di servizi diversi nella stessa transazione. Questa non è una vera gerarchia ma una reificazione necessaria per la complessità del dominio.

\subsection{Reificazione associazioni molti-a-molti}

Le associazioni molti-a-molti sono state trasformate in entità intermedie con relazioni uno-a-molti.

\subsubsection{Ordini e Prodotti}

L'associazione tra ORDER e PRODUCT è stata reificata nell'entità ORDER\_DETAIL, che registra quantità e prezzo unitario per ogni prodotto ordinato.

\subsubsection{Prenotazioni e Servizi}

L'associazione tra RESERVATION e SERVICE è stata reificata in RESERVATION\_DETAIL, che memorizza date, orari e numero di persone per ogni servizio prenotato.

\subsubsection{Eventi e Utenti}

L'associazione tra EVENT e USER è stata reificata in EVENT\_SUBSCRIPTION, che traccia il numero di partecipanti per ogni iscrizione.

\subsubsection{Dipendenti e Turni}

L'associazione tra EMPLOYEE e SHIFT è stata reificata in EMPLOYEE\_SHIFT, che registra lo stato e la data specifica del turno.

\subsection{Scelta degli identificatori principali}

Per ogni entità abbiamo scelto identificatori che garantiscano univocità e stabilità:

\subsubsection{Identificatori naturali}

\begin{itemize}
    \item \textbf{PERSON}: \textit{cf} (codice fiscale) come identificatore naturale
    \item \textbf{USER}: \textit{username} come identificatore univoco
    \item \textbf{EMPLOYEE}: \textit{username} (ereditato da USER)
    \item \textbf{PRODUCT}: \textit{id} auto-incrementale
    \item \textbf{EVENT}: \textit{id} auto-incrementale
\end{itemize}

\subsubsection{Identificatori artificiali}

Per alcune entità abbiamo introdotto identificatori artificiali per semplificare le relazioni:

\begin{itemize}
    \item \textbf{SERVICE}: \textit{id} auto-incrementale
    \item \textbf{ORDER}: \textit{id} auto-incrementale
    \item \textbf{RESERVATION}: \textit{id} auto-incrementale
    \item \textbf{REVIEW}: \textit{id} auto-incrementale
    \item \textbf{SHIFT}: \textit{id} auto-incrementale
\end{itemize}

\subsubsection{Identificatori composti}

Per le entità derivate da reificazioni, abbiamo utilizzato identificatori composti:

\begin{itemize}
    \item \textbf{ORDER\_DETAIL}: (\textit{order}, \textit{product})
    \item \textbf{RESERVATION\_DETAIL}: (\textit{reservation}, \textit{service})
    \item \textbf{EVENT\_SUBSCRIPTION}: (\textit{event}, \textit{user})
    \item \textbf{EMPLOYEE\_SHIFT}: (\textit{employee}, \textit{shift}, \textit{shift\_date})
\end{itemize}

\subsection{Scelte progettuali significative}

\subsubsection{Flessibilità del catalogo servizi}

La decisione di non collassare la gerarchia di SERVICE rappresenta una scelta progettuale importante. Questo approccio permette:

1. \textbf{Espandibilità}: Nuovi tipi di servizi possono essere aggiunti creando semplicemente nuove tabelle specializzate
2. \textbf{Separazione delle concerns}: Ogni tipo di servizio mantiene i propri attributi specifici
3. \textbf{Query efficienti}: Il campo \textit{type} in SERVICE permette filtri rapidi senza JOIN non necessari
4. \textbf{Integrità referenziale}: Le prenotazioni referenziano SERVICE, non i servizi specifici

\subsubsection{Gestione storica del personale}

L'entità EMPLOYEE\_HISTORY permette di tracciare le variazioni di ruolo nel tempo, soddisfacendo il requisito di audit trail per il personale.

\subsubsection{Separazione identità e autenticazione}

La separazione tra PERSON e USER garantisce che i dati anagrafici siano mantenuti separatamente dalle credenziali di accesso, migliorando la sicurezza e la gestione dei dati.

\section{Schema relazionale finale}

Dopo aver applicato tutti i raffinamenti, lo schema relazionale finale è rappresentato dalle seguenti tabelle:

\begin{itemize}
    \item \textbf{PERSON} (\underline{cf}, name, surname)
    \item \textbf{USER} (\underline{username}, email, password, cf: PERSON)
    \item \textbf{EMPLOYEE} (\underline{username}, role)
    \item \textbf{EMPLOYEE\_HISTORY} (\underline{username}, fixed\_at, role)
    \item \textbf{PRODUCT} (\underline{id}, name, description, price)
    \item \textbf{EVENT} (\underline{id}, title, description, event\_date, seats)
    \item \textbf{SERVICE} (\underline{id}, price, type)
    \item \textbf{ROOM} (\underline{code}, max\_capacity, service: SERVICE)
    \item \textbf{RESTAURANT} (\underline{code}, max\_capacity, service: SERVICE)
    \item \textbf{ORDER} (\underline{id}, date, username: USER)
    \item \textbf{ORDER\_DETAIL} (\underline{order: ORDER, product: PRODUCT}, quantity, unit\_price)
    \item \textbf{RESERVATION} (\underline{id}, reservation\_date, username: USER)
    \item \textbf{RESERVATION\_DETAIL} (\underline{reservation: RESERVATION, service: SERVICE}, start\_date, end\_date, people)
    \item \textbf{EVENT\_SUBSCRIPTION} (\underline{event: EVENT, user: USER}, participants, subscription\_date)
    \item \textbf{REVIEW} (\underline{id}, rating, comment, created\_at, user: USER, event: EVENT, service: SERVICE)
    \item \textbf{SHIFT} (\underline{id}, shift\_name, day\_of\_week, start\_time, end\_time)
    \item \textbf{EMPLOYEE\_SHIFT} (\underline{employee: EMPLOYEE, shift: SHIFT, shift\_date}, status)
\end{itemize}

La fase di riorganizzazione è ora conclusa e lo schema ottenuto è
immediatamente traducibile in relazioni relazionali. Di seguito
presentiamo lo schema logico.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth, trim=0 0 0 0]{./schemas/logic.pdf}
  \caption{Schema relazione finale}
  \label{fig:schema-relazione}
\end{figure}
\newpage


\chapter{Progettazione della Base di Dati}
Una volta creato il nostro database, riportiamo di seguito una parte
del codice relazionale
utilizzato per la sua implementazione.

\section{Check}
Sono stati utilizzati vincoli di tipo \texttt{CHECK} per definire
alcuni domini e assicurare
semplici proprietà degli attributi. Di seguito un esempio di vincolo
\texttt{CHECK} utilizzato
per assicurare che il prezzo di ogni prodotto sia maggiore zero:

% tex-fmt: off
\begin{sqlcode}[caption={},label={lst:check}]
CREATE TABLE PRODUCT (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT NOT NULL,
    price DECIMAL(8,2) NOT NULL CHECK (price > 0)
);
\end{sqlcode}
% tex-fmt: on

\section{Viste}
La seguente vista \texttt{active\_employees} restituisce l'elenco dei
dipendenti attivi,
mostrando per ciascuno username, email, nome, cognome e ruolo. Un
dipendente è considerato
attivo se il suo username non compare nella tabella
\texttt{EMPLOYEE\_HISTORY}, che traccia
lo storico delle variazioni di stato.

% tex-fmt: off
\begin{sqlcode}[caption={},label={lst:view}]
CREATE VIEW active_employees AS
SELECT
    e.username,
    u.email,
    p.name,
    p.surname,
    e.role
FROM EMPLOYEE e
JOIN USER u ON e.username = u.username
JOIN PERSON p ON u.cf = p.cf
WHERE e.username NOT IN (
    SELECT username FROM EMPLOYEE_HISTORY
  );
\end{sqlcode}
% tex-fmt: on

\section{Trigger}
Esempio di trigger per vincolare le recensioni: impedisce di
recensire sia evento che servizio
insieme, e consente la recensione solo se l'utente ha partecipato
all'evento (già svolto) o ha
usufruito del servizio.

% tex-fmt: off
\begin{sqlcode}[caption={},label={lst:trigger}]
DROP TRIGGER IF EXISTS trg_review_before_insert;
DELIMITER $$
CREATE TRIGGER trg_review_before_insert
BEFORE INSERT ON REVIEW
FOR EACH ROW
BEGIN
    DECLARE cnt INT DEFAULT 0;

    IF (NEW.event IS NOT NULL AND NEW.service IS NOT NULL) OR (NEW.event IS NULL AND NEW.service IS NULL) THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Set either event or service (not both) for the review.';
    END IF;

    IF NEW.event IS NOT NULL THEN
        SELECT COUNT(*)
            INTO cnt
            FROM EVENT e
            JOIN EVENT_SUBSCRIPTION es
                ON es.event = e.id
             AND es.`user` = NEW.`user`
         WHERE e.id = NEW.event
             AND e.event_date < CURDATE();

        IF cnt = 0 THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'You can review the event only if you were subscribed and the event date is in the past.';
        END IF;
    END IF;

    IF NEW.service IS NOT NULL THEN
        SELECT COUNT(*)
            INTO cnt
            FROM RESERVATION r
            JOIN RESERVATION_DETAIL rd
                ON rd.reservation = r.id
             AND rd.service = NEW.service
         WHERE r.username = NEW.`user`
             AND rd.end_date < NOW();

        IF cnt = 0 THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'You can review the service only after you have used it (completed reservation).';
        END IF;
    END IF;
END$$
DELIMITER ;
\end{sqlcode}
% tex-fmt: on

\section{Traduzione delle operazioni} 
In questa sezione vengono presentate le query SQL che implementano le principali operazioni del sistema agriturismo. Le query sono state progettate per essere efficienti e sfruttare gli indici e i vincoli definiti nello schema. 

\subsection{Visualizzazione statistiche dashboard} 
Le seguenti query sono utilizzate per popolare la dashboard amministrativa con le metriche principali del sistema. 

\subsubsection{Top servizi per prenotazioni} 
Questa operazione analizza le prenotazioni per identificare i servizi più richiesti, distinguendo tra ristoranti e camere attraverso un'articolata procedura di join e raggruppamento.

\begin{sqlcode}[caption={Query per i servizi più prenotati}]
SELECT CASE WHEN s.type = 'RESTAURANT' THEN CONCAT('Restaurant - ', r.code) 
            WHEN s.type = 'ROOM' THEN CONCAT('Room - ', ro.code) 
            ELSE s.type END as service_name,
       COUNT(rd.service) as booking_count 
FROM SERVICE s 
LEFT JOIN RESTAURANT r ON s.id = r.service 
LEFT JOIN ROOM ro ON s.id = ro.service 
JOIN RESERVATION_DETAIL rd ON s.id = rd.service 
GROUP BY s.id, s.type, r.code, ro.code 
ORDER BY booking_count DESC 
LIMIT 4;
\end{sqlcode}

\subsubsection{Top prodotti per quantità venduta} 
Questa operazione calcola i prodotti più venduti in base alla quantità totale ordinata.

\begin{sqlcode}[caption={Query per i prodotti più venduti}]
SELECT p.name as product_name, SUM(od.quantity) as total_quantity 
FROM PRODUCT p 
JOIN ORDER_DETAIL od ON p.id = od.product 
GROUP BY p.id, p.name 
ORDER BY total_quantity DESC 
LIMIT 6;
\end{sqlcode}

\subsubsection{Top eventi per partecipanti} 
Questa operazione determina gli eventi con il maggior numero di partecipanti totali.

\begin{sqlcode}[caption={Query per gli eventi più partecipati}]
SELECT e.title as event_title, e.event_date, SUM(es.participants) as total_participants 
FROM EVENT e 
JOIN EVENT_SUBSCRIPTION es ON e.id = es.event 
GROUP BY e.id, e.title, e.event_date 
ORDER BY total_participants DESC 
LIMIT 4;
\end{sqlcode}

\subsubsection{Top prodotti per fatturato} 
Questa operazione calcola i prodotti che generano il maggior fatturato.

\begin{sqlcode}[caption={Query per i prodotti per fatturato}]
SELECT p.name as product_name, SUM(od.quantity * od.unit_price) as total_revenue 
FROM PRODUCT p 
JOIN ORDER_DETAIL od ON p.id = od.product 
GROUP BY p.id, p.name 
ORDER BY total_revenue DESC 
LIMIT 6;
\end{sqlcode}

\subsubsection{Fatturato totale} 
Questa operazione calcola il ricavo complessivo generato dalle vendite dei prodotti.

\begin{sqlcode}[caption={Query per il fatturato totale}]
SELECT ROUND(SUM(od.quantity * od.unit_price), 2) as overall_total_revenue 
FROM ORDER_DETAIL od;
\end{sqlcode}

\subsubsection{Statistiche generali del sistema} 
Questa query composita fornisce un riepilogo completo delle metriche di sistema attraverso sottoselezioni multiple, aggregando dati da diverse tabelle per offrire una visione d'insieme immediata.

\begin{sqlcode}[caption={Query per le statistiche generali}]
SELECT (SELECT COUNT(*) FROM USER) as total_customers,
       (SELECT COUNT(*) FROM EMPLOYEE) as total_employees,
       (SELECT COUNT(*) FROM ORDERS) as total_orders,
       (SELECT ROUND(SUM(od.quantity * od.unit_price), 2) FROM ORDER_DETAIL od) as total_revenue,
       (SELECT COUNT(*) FROM RESERVATION) as total_reservations;
\end{sqlcode}

\subsection{Prenotazione servizi} 

\subsubsection{Verifica disponibilità camere} 
La query verifica la disponibilità camere analizzando le prenotazioni esistenti attraverso una condizione di non sovrapposizione temporale, garantendo che vengano selezionate solo le camere con capacità sufficiente e libere nel periodo richiesto.

\begin{sqlcode}[caption={Query per la disponibilità camere}]
SELECT ro.code AS camera, s.price AS prezzo, ro.max_capacity 
FROM ROOM ro 
JOIN SERVICE s ON s.id = ro.service 
WHERE ro.max_capacity >= @n_persone 
  AND ro.service NOT IN (
    SELECT rd.service 
    FROM RESERVATION_DETAIL rd 
    WHERE NOT (rd.end_date <= @data_inizio OR rd.start_date >= @data_fine)
  );
\end{sqlcode}

\subsubsection{Verifica disponibilità tavoli} 
Questa complessa query calcola i posti disponibili considerando le prenotazioni esistenti che si sovrappongono all'intervallo richiesto, utilizzando un left join condizionato e una clausola having per filtrare i ristoranti con posti sufficienti.

\begin{sqlcode}[caption={Query per la disponibilità tavoli}]
SELECT r.code AS ristorante, s.price AS prezzo, r.max_capacity,
       (r.max_capacity - IFNULL(SUM(rd.people), 0)) AS posti_disponibili 
FROM RESTAURANT r 
JOIN SERVICE s ON s.id = r.service 
LEFT JOIN RESERVATION_DETAIL rd ON rd.service = r.service 
  AND NOT (rd.end_date <= @data_inizio OR rd.start_date >= @data_fine) 
GROUP BY r.service, r.code, s.price, r.max_capacity 
HAVING posti_disponibili >= @n_partecipanti;
\end{sqlcode}

\subsection{Gestione recensioni} 

\subsubsection{Inserimento recensione evento} 
L'operazione verifica tramite multiple condizioni che l'utente sia iscritto all'evento, che questo sia concluso, e che non esista già una recensione da parte dell'user riguardante quell'evento, implementando così un controllo di integrità complesso prima dell'inserimento.

\begin{sqlcode}[caption={Query per inserimento recensione evento}]
INSERT INTO REVIEW (user, event, rating, comment) 
SELECT 'mrossi' as user, e.id as event, 5 as rating, 
       'Amazing experience! Will definitely come again.' as comment 
FROM EVENT e 
INNER JOIN EVENT_SUBSCRIPTION es ON e.id = es.event AND es.user = 'mrossi' 
WHERE e.title = 'Farm Open Day' 
  AND e.event_date < CURDATE() 
  AND NOT EXISTS (
    SELECT 1 
    FROM REVIEW r 
    WHERE r.user = 'mrossi' AND r.event = e.id
  ) 
LIMIT 1;
\end{sqlcode}

\subsubsection{Inserimento recensione servizio} 
La query implementa un meccanismo di controllo articolato che verifica l'esistenza di una prenotazione completata e l'assenza di recensioni duplicate, garantendo la correttezza referenziale dell'inserimento.

\begin{sqlcode}[caption={Query per inserimento recensione servizio}]
INSERT INTO REVIEW (user, service, rating, comment) 
SELECT 'aneri' as user, s.id as service, 4 as rating, 
       'Good service and friendly staff.' as comment 
FROM SERVICE s 
INNER JOIN RESERVATION_DETAIL rd ON s.id = rd.service 
INNER JOIN RESERVATION r ON rd.reservation = r.id 
WHERE r.username = 'aneri' 
  AND rd.end_date < NOW() 
  AND s.type = 'RESTAURANT' 
  AND NOT EXISTS (
    SELECT 1 
    FROM REVIEW rev 
    WHERE rev.user = 'aneri' AND rev.service = s.id
  ) 
LIMIT 1;
\end{sqlcode}

\subsubsection{Aggiornamento recensione} 
Questa operazione modifica il voto e il commento di una recensione esistente.

\begin{sqlcode}[caption={Query per aggiornamento recensione}]
UPDATE REVIEW 
SET rating = 4, 
    comment = 'Very good event, but could use more activities. Overall enjoyed it!',
    created_at = NOW() 
WHERE user = 'mrossi' 
  AND event = (SELECT id FROM EVENT WHERE title = 'Farm Open Day') 
  AND id IS NOT NULL;
\end{sqlcode}

\subsection{Gestione iscrizioni eventi} 

\subsubsection{Update e Iscrizione utente a evento} 
Questa operazione permette a un utente di iscriversi a un evento specificando il numero di partecipanti, con un meccanismo di controllo "ON DUPLICATE KEY UPDATE" siamo in grado di trasformare questa insert in un update che modifica solo il numero di partecipanti, nel caso in cui l'utente avesse gia effettuato un'iscrizione al dato evento.

\begin{sqlcode}[caption={Query per iscrizione evento}]
INSERT INTO EVENT_SUBSCRIPTION (event, user, participants)
SELECT 
    e.id,
    u.username,
    4
FROM EVENT e
CROSS JOIN USER u
WHERE e.title = 'Harvest Festival' 
    AND u.username = 'lblu'
ON DUPLICATE KEY UPDATE participants = 4;
\end{sqlcode}



\subsection{Gestione prenotazioni servizi} 

\subsubsection{Creazione prenotazione principale} 
Questa operazione crea il record principale di prenotazione per un utente, con un controllo che evita la creazione di prenotazioni duplicate nella stessa giornata.

\begin{sqlcode}[caption={Query per creazione prenotazione principale}]
INSERT INTO RESERVATION (username, reservation_date)
SELECT 'gverdi', NOW()
WHERE NOT EXISTS (
    SELECT 1 FROM RESERVATION 
    WHERE username = 'gverdi' 
    AND DATE(reservation_date) = CURDATE()
);
\end{sqlcode}


\subsubsection{Prenotazione tavolo ristorante} 
Query specializzata per la prenotazione di tavoli al ristorante, con join sulla tabella RESTAURANT per identificare il servizio corretto.

\begin{sqlcode}[caption={Query per prenotazione tavolo ristorante}]
SET @new_reservation_id = LAST_INSERT_ID();

INSERT INTO RESERVATION_DETAIL (reservation, service, start_date, end_date, people)
SELECT 
    @new_reservation_id as reservation,
    s.id as service,
    '2024-01-25 19:00:00' as start_date,
    '2024-01-25 21:00:00' as end_date,
    2 as people
FROM SERVICE s
INNER JOIN RESTAURANT r ON s.id = r.service
WHERE r.code = 'T01'
LIMIT 1;
\end{sqlcode}

\subsubsection{Prenotazione camera con controllo duplicati} 
Operazione completa per la prenotazione di camere che include sia la creazione della prenotazione principale che dei dettagli, con controlli anti-duplicato e gestione degli ID generati.

\begin{sqlcode}[caption={Query per prenotazione camera}]
INSERT INTO RESERVATION (username, reservation_date)
SELECT 'fbianchi', DATE_ADD(NOW(), INTERVAL 1 HOUR)
WHERE NOT EXISTS (
    SELECT 1 FROM RESERVATION 
    WHERE username = 'fbianchi' 
    AND DATE(reservation_date) = CURDATE()
);

SET @room_reservation_id = LAST_INSERT_ID();

INSERT INTO RESERVATION_DETAIL (reservation, service, start_date, end_date, people)
SELECT 
    @room_reservation_id as reservation,
    s.id as service,
    '2024-01-26 15:00:00' as start_date,
    '2024-01-28 11:00:00' as end_date,
    2 as people
FROM SERVICE s
INNER JOIN ROOM r ON s.id = r.service
WHERE r.code = 'R03'
LIMIT 1;
\end{sqlcode}

\subsection{Eliminazione prenotazioni e iscrizioni}

\subsubsection{Eliminazione prenotazione servizio}
Questa operazione permette di cancellare una prenotazione di servizio esistente, rimuovendo prima i dettagli della prenotazione per rispettare i vincoli di integrità referenziale e successivamente il record principale della prenotazione.

\begin{sqlcode}[caption={Query per eliminazione prenotazione servizio}]
-- Prima eliminiamo i dettagli della prenotazione per evitare violazioni dei vincoli
DELETE FROM RESERVATION_DETAIL 
WHERE reservation = @reservation_id;

-- Poi eliminiamo la prenotazione principale
DELETE FROM RESERVATION 
WHERE id = @reservation_id 
  AND username = @username;
\end{sqlcode}

\subsubsection{Eliminazione iscrizione evento}
Questa operazione rimuove l'iscrizione di un utente a un evento specifico, verificando che l'iscrizione esista e che l'evento non sia già iniziato per consentire solo cancellazioni di eventi futuri.

\begin{sqlcode}[caption={Query per eliminazione iscrizione evento}]
DELETE FROM EVENT_SUBSCRIPTION 
WHERE user = @username 
  AND event = @event_id
  AND EXISTS (
    SELECT 1 FROM EVENT e 
    WHERE e.id = @event_id 
    AND e.event_date > CURDATE()
  );
\end{sqlcode}

\subsubsection{Eliminazione prenotazione con controllo temporale}
Questa query più sofisticata elimina una prenotazione solo se non è già iniziata, implementando un controllo temporale che previene la cancellazione di prenotazioni in corso o concluse.

\begin{sqlcode}[caption={Query per eliminazione prenotazione con controllo temporale}]
-- Eliminazione condizionata: solo se la prenotazione non e' iniziata
DELETE FROM RESERVATION 
WHERE id = @reservation_id 
  AND username = @username
  AND NOT EXISTS (
    SELECT 1 FROM RESERVATION_DETAIL rd 
    WHERE rd.reservation = @reservation_id 
    AND rd.start_date <= NOW()
  );
\end{sqlcode}

\subsubsection{Eliminazione multipla iscrizioni evento}
Operazione amministrativa che permette di cancellare tutte le iscrizioni a un evento specifico, utile in caso di cancellazione dell'evento da parte degli amministratori del sistema.

\begin{sqlcode}[caption={Query per eliminazione multipla iscrizioni evento}]
DELETE FROM EVENT_SUBSCRIPTION 
WHERE event = @event_id;
\end{sqlcode}

\subsection{Autenticazione utente} 

\subsubsection{Verifica credenziali di login} 
La query combina informazioni da multiple tabelle per validare le credenziali e determinare il profilo utente completo, distinguendo tra dipendenti e clienti attraverso un left join strategico.

\begin{sqlcode}[caption={Query per verifica login}]
SELECT u.username, u.email, u.password, p.name, p.surname,
       CASE WHEN e.username IS NOT NULL THEN 'employee' ELSE 'customer' END as user_type,
       e.role as employee_role 
FROM USER u 
INNER JOIN PERSON p ON u.cf = p.cf 
LEFT JOIN EMPLOYEE e ON u.username = e.username 
WHERE u.username = 'mrossi' OR u.email = 'mrossi@farm.com';
\end{sqlcode}

\subsection{Gestione ordini prodotti} 

\subsubsection{Creazione nuovo ordine} 
Questa complessa transazione articolata in multiple operazioni crea un nuovo ordine, recupera automaticamente l'ID generato, e inserisce i prodotti con i prezzi correnti, gestendo così tutta la logica di ordine in un'unica procedura.

\begin{sqlcode}[caption={Query per creazione ordine}]
INSERT INTO ORDERS (username, date) 
SELECT 'aneri', NOW() 
WHERE NOT EXISTS (
  SELECT 1 
  FROM ORDERS 
  WHERE username = 'aneri' AND DATE(date) = CURDATE()
);

SET @new_order_id = LAST_INSERT_ID();

INSERT INTO ORDER_DETAIL (order, product, quantity, unit_price) 
SELECT @new_order_id as order_id, p.id as product_id, 3 as quantity, p.price as unit_price 
FROM PRODUCT p 
WHERE p.name = 'Farm Eggs (12 pcs)' 
LIMIT 1;

INSERT INTO ORDER_DETAIL (order, product, quantity, unit_price) 
SELECT @new_order_id as order_id, p.id as product_id, 2 as quantity, p.price as unit_price 
FROM PRODUCT p 
WHERE p.name = 'Fresh Bread' 
LIMIT 1;

INSERT INTO ORDER_DETAIL (order, product, quantity, unit_price) 
SELECT @new_order_id as order_id, p.id as product_id, 1 as quantity, p.price as unit_price 
FROM PRODUCT p 
WHERE p.name = 'Honey Jar (500g)' 
LIMIT 1;
\end{sqlcode}

\chapter{Progettazione dell'applicazione}
L'applicazione è stata sviluppata con il framework \textbf{Django},
che gestisce routing,
database e autenticazione in modo sicuro e scalabile.

\section{Barra di Navigazione}
La \textbf{barra di navigazione} permette un accesso rapido alle
principali sezioni del sito,
come prodotti, eventi, servizi, area personale e funzioni amministrative.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth, trim=0 0 0 0]{./img/navbar.png}
  \caption{Barra di navigazione}
  \label{fig:navbar}
\end{figure}

\newpage
\subsection*{Login}

Il form di login consente agli utenti registrati di accedere
rapidamente alla piattaforma inserendo username e
password. Il sistema verifica le credenziali e, in caso di errore,
mostra un messaggio di avviso.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth, trim=0 0 0 0]{./img/login.png}
  \vspace{-1em}
  \label{fig:login}
\end{figure}

\subsection*{Registrazione}
Anche per registrarsi è disponibile un form semplice e intuitivo, che
permette agli utenti di creare un nuovo
account inserendo i dati richiesti. Dopo la registrazione, l'utente
potrà accedere a tutte le funzionalità della
piattaforma.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth, trim=0 0 0 0]{./img/register.png}
  \vspace{-1em}
  \label{fig:registrazione}
\end{figure}

\newpage
\section{Interfaccia Utente}
Dopo l'accesso, l'utente potrà visualizzare il profilo, con le
prenotazioni e gli ordini, con
la possibilità di recensire o annullare prenotazioni future.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth, trim=0 0 0 0]{./img/users/profile.png}
  \vspace{-1em}
  \label{fig:profile}
\end{figure}

\subsection*{Servizi}
Dopo aver scelto il servizio da prenotare, è sufficiente inserire i
dati necessari; il sistema
mostrerà la disponibilità aggiornata del servizio selezionato.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth, trim=0 0 0 0]{./img/users/services.png}
  \vspace{-1em}
  \label{fig:services}
\end{figure}

\subsection*{Eventi}
Nella sezione eventi, viene mostrato l'elenco degli eventi
disponibili. L'utente può selezionare
l'evento di interesse, specificare il numero di partecipanti e
procedere con la prenotazione.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth, trim=0 0 0 0]{./img/users/events.png}
  \vspace{-1em}
  \label{fig:events}
\end{figure}

\subsection*{Recensioni}
Gli utenti possono visualizzare tutte le recensioni e filtrarle per
evento o servizio.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth, trim=0 0 0 0]{./img/users/reviews.png}
  \vspace{-1em}
  \label{fig:recensione}
\end{figure}

Il form permette agli utenti di lasciare una recensione su eventi o
servizi a cui hanno partecipato,
inserendo commento e voto. La recensione è consentita solo dopo la
partecipazione effettiva.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth, trim=0 0 0 0]{./img/users/give_review.png}
  \vspace{-1em}
  \label{fig:lascia recensione}
\end{figure}

\subsection*{Prodotti}
La sezione prodotti consente agli utenti di consultare il catalogo
aggiungerli al carrello per
l'acquisto. Il sistema mostra in tempo reale il contenuto del
carrello e il totale dell'ordine.
Fatto il checkout sarà visibile il riepilogo nella sezione profilo.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth, trim=0 0 0 0]{./img/users/products.png}
  \vspace{-1em}
  \label{fig:products}
\end{figure}

\subsection*{Carrello}
Il \textbf{carrello} è una funzionalità applicativa che consente agli
utenti di selezionare e
gestire i prodotti da acquistare prima di confermare l'ordine. Il
carrello non è rappresentato
nel database, ma viene gestito lato applicazione: i prodotti
selezionati vengono memorizzati
temporaneamente fino al checkout, momento in cui viene creato
l'ordine definitivo e
registrato nel sistema.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth, trim=0 0 0 0]{./img/users/cart.png}
  \vspace{-1em}
  \label{fig:cart}
\end{figure}

\newpage
\section{Interfaccia Amministratore}
Per la gestione amministrativa, l'applicazione sfrutta la sezione
\textbf{Django Admin},
che consente agli amministratori di accedere rapidamente a tutte le
tabelle del database,
modificare dati, tramite un'interfaccia web sicura e strutturata.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth, trim=0 0 0 0]{./img/admin/djangoAdmin.png}
  \vspace{-1em}
  \label{fig:django-admin}
\end{figure}

Oltre al pannello standard di Django Admin, è stata realizzata una
pagina web dedicata alla
visualizzazione delle statistiche principali del sistema, come
l'andamento delle vendite, la
partecipazione agli eventi e la presenza del personale. Questa pagina
presenta tabelle
riepilogative.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth, trim=0 0 0 0]{./img/admin/statistic.png}
  \vspace{-1em}
  \label{fig:statistiche}
\end{figure}

\appendix
\chapter{Guida Utente}

\section{Clonazione del repository}
Clonare il progetto da GitHub e accedere alla cartella:

\begin{verbatim}
> git clone https://github.com/alessandrorebosio/D25-farmhouse.git
> cd DB25-farmhouse
\end{verbatim}

\section{Installazione delle dipendenze}

Si consiglia di utilizzare un ambiente virtuale Python per isolare le
dipendenze del progetto.

\begin{verbatim}
> python3 -m venv venv
\end{verbatim}

\noindent Attivazione dell'ambiente virtuale
\begin{verbatim}
# Su Linux/macOS:
> source venv/bin/activate
# Su Windows:
> venv\Scripts\activate
\end{verbatim}

\noindent Installazione delle dipendenze dal file requirements.txt
\begin{verbatim}
> pip install -r requirements.txt
\end{verbatim}

\section{Creazione del database}
Per creare il database MySQL a partire dagli script SQL forniti,
assicurarsi di avere MySQL
installato e in esecuzione.

\begin{verbatim}
> mysql -u root -p < app/sql/db.sql
> mysql -u root -p < app/sql/demo.sql
\end{verbatim}

Verrà richiesta la password dell'utente \texttt{root}. Il comando
eseguirà tutte le
istruzioni SQL contenute nel file \texttt{db.sql}, creando tabelle,
vincoli e dati di
esempio necessari per l'applicazione.

\section{Avvio dell'applicazione}

Per avviare l'applicazione Django, assicurarsi che l'ambiente
virtuale sia attivo e che il database
sia stato creato correttamente.

\begin{verbatim}
> python manage.py migrate
> python manage.py runserver
\end{verbatim}

L'applicazione sarà accessibile all'indirizzo
\url{http://localhost:8000/} tramite browser. Effettuare
il login o la registrazione per iniziare a utilizzare il sistema.

\end{document}
